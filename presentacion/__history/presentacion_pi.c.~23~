#include <16f877a.h>
#include <math.h>  // Para usar atan

#fuses HS, NOWDT, NOPROTECT, NOPUT, NOLVP, NOBROWNOUT
#use delay(clock=20000000)
#use I2C(MASTER, SDA=PIN_C4, SCL=PIN_C3, SLOW)

#use standard_io(D)
#use standard_io(A)
#define use_servo_1 
#define use_servo_2
// Definiciones de pines para los servos
#define servo_1 PIN_A0
#define servo_2 PIN_A1

// Librería adicional para el manejo de servos
#define BUTTON_UP PIN_B1      // Botón para incrementar valor
#define BUTTON_DOWN PIN_B2    // Botón para decrementar valor
#define BUTTON_SELECT PIN_B3  // Botón para confirmar selección
#define BUTTON_MENU PIN_B0  

#include <lcd.c>         // Librería para el manejo de la LCD
#include <MPU6050.c>     // Librería para el manejo del MPU6050
#include <servo_st.c>    // Librería para servos


// Variables para PID y Setpoint para X y Y
float kp_x = 0.2, ki_x = 0.05, kd_x = 0.01;
float kp_y = 0.2, ki_y = 0.05, kd_y = 0.01;
float setpoint_x = 0.0, setpoint_y = 0.0;  // Setpoints en grados
float last_error_x = 0.0, integral_x = 0.0;
float last_error_y = 0.0, integral_y = 0.0;

// Rango permitido cercano al cero
float tolerance = 2.0;  // Rango de ±2 grados

// Variables para control de tiempo
unsigned long last_time = 0;  // Almacenará el último tiempo en milisegundos

// Función para obtener el valor absoluto de un número de punto flotante
float abs_float(float value) {
    return value < 0 ? -value : value;
}

// Función PID para controlar cada eje
float pid_control_x(float input) {
    float error = setpoint_x - input;

    if (abs_float(error) < tolerance) {
        error = 0;  // Si el error es menor que el rango, no ajustar más
    }

    integral_x += error;
    float derivative = error - last_error_x;
    float output = kp_x * error + ki_x * integral_x + kd_x * derivative;
    last_error_x = error;

    // Limitar la salida PID entre 0 y 180 grados
    if (output < 0.0) output = 0.0;
    if (output > 180.0) output = 180.0;
    return output;
}

float pid_control_y(float input) {
    float error = setpoint_y - input;

    if (abs_float(error) < tolerance) {
        error = 0;
    }

    integral_y += error;
    float derivative = error - last_error_y;
    float output = kp_y * error + ki_y * integral_y + kd_y * derivative;
    last_error_y = error;

    if (output < 0.0) output = 0.0;
    if (output > 180.0) output = 180.0;
    return output;
}

// Función para mostrar el menú de configuración PID
void pid_menu() {
    int option = 0;
    int done = 0;

    while (!done) {
        lcd_putc("\f");  // Limpiar pantalla
        lcd_gotoxy(1, 1);

        switch (option) {
            case 0:
                printf(lcd_putc, "Kp X: %.2f", kp_x);
                break;
            case 1:
                printf(lcd_putc, "Ki X: %.2f", ki_x);
                break;
            case 2:
                printf(lcd_putc, "Kd X: %.2f", kd_x);
                break;
            case 3:
                printf(lcd_putc, "Kp Y: %.2f", kp_y);
                break;
            case 4:
                printf(lcd_putc, "Ki Y: %.2f", ki_y);
                break;
            case 5:
                printf(lcd_putc, "Kd Y: %.2f", kd_y);
                break;
            case 6:
                printf(lcd_putc, "Setpoint X: %.2f", setpoint_x);
                break;
            case 7:
                printf(lcd_putc, "Setpoint Y: %.2f", setpoint_y);
                break;
        }

        if (input(BUTTON_UP) == 0) {
            while (input(BUTTON_UP) == 0);
            switch (option) {
                case 0: kp_x += 0.05; break;
                case 1: ki_x += 0.1; break;
                case 2: kd_x += 0.01; break;
                case 3: kp_y += 0.05; break;
                case 4: ki_y += 0.1; break;
                case 5: kd_y += 0.01; break;
                case 6: setpoint_x += 0.1; break;
                case 7: setpoint_y += 0.1; break;
            }
        }

        if (input(BUTTON_DOWN) == 0) {
            while (input(BUTTON_DOWN) == 0);
            switch (option) {
                case 0: kp_x -= 0.05; break;
                case 1: ki_x -= 0.1; break;
                case 2: kd_x -= 0.01; break;
                case 3: kp_y -= 0.05; break;
                case 4: ki_y -= 0.1; break;
                case 5: kd_y -= 0.01; break;
                case 6: setpoint_x -= 0.1; break;
                case 7: setpoint_y -= 0.1; break;
            }
        }

        if (input(BUTTON_SELECT) == 0) {
            while (input(BUTTON_SELECT) == 0);
            option++;
            if (option > 7) {
                done = 1;
            }
        }
        delay_ms(200);
    }
}

// Rutina de interrupción para el menú PID
#INT_EXT
void interrupt_rb0() {
    pid_menu();
}

void main() {
    lcd_init();
    MPU6050_init();  // Inicializa el MPU6050
    servo_init();    // Inicializa los servos
    enable_interrupts(INT_EXT);
    enable_interrupts(GLOBAL);
    ext_int_edge(H_TO_L);

    printf(lcd_putc, "BIENVENIDO");

    float Ax, Ay, servo_x_output, servo_y_output;

    while (true) {
        unsigned long current_time = millis();  // Obtener el tiempo actual

        // Verificar si ha pasado 1000 ms (1 segundo)
        if (current_time - last_time >= 1000) {
            last_time = current_time;  // Actualizar el último tiempo

            // Obtener los valores de los ángulos
            Ax = MPU6050_get_Ax();  // Obtener valor en el eje X
            Ay = MPU6050_get_Ay();  // Obtener valor en el eje Y

            // Mostrar los valores de los ángulos en la pantalla LCD
            lcd_gotoxy(1, 1);
            printf(lcd_putc, "\fAx: %.2f Ay: %.2f", Ax, Ay);  // Mostrar como valores flotantes para precisión

            // Corrección priorizando el eje más inclinado
            if (abs_float(Ay) > abs_float(Ax) && abs_float(Ay) > tolerance) {
                // Corrige el eje Y
                servo_y_output = pid_control_y(Ay);
                servo_2_write(servo_y_output);
                 servo_1_write(120);   // Mueve el servo 1 a angle_x
                 delay_ms(500);           // Espera para que el servo complete el movimiento
                 servo_1_write(90);   // Mueve el servo 2 a angle_y
                 delay_ms(500); // Mueve el servo en el eje Y
            } 
            else if (abs_float(Ax) > tolerance) {
                // Corrige el eje X
                servo_x_output = pid_control_x(Ax);
                servo_1_write(servo_x_output);
                 servo_2_write(70);   // Mueve el servo 1 a angle_x
                 delay_ms(500);           // Espera para que el servo complete el movimiento
                 servo_2_write(90);   // Mueve el servo 2 a angle_y
                 delay_ms(500);// Mueve el servo en el eje X
            }

            delay_ms(100);  // Espera corta para evitar saturar el sistema
        }
    }
}
