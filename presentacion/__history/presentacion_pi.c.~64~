#include <16f877a.h>
#include <math.h>  // Para usar atan

#fuses HS, NOWDT, NOPROTECT, NOPUT, NOLVP, NOBROWNOUT
#use delay(clock=20000000)
#use I2C(MASTER, SDA=PIN_C4, SCL=PIN_C3, SLOW)

#use standard_io(D)
#use standard_io(A)
#define use_servo_1 
#define use_servo_2
// Definiciones de pines para los servos
#define servo_1 PIN_A0
#define servo_2 PIN_A1

#include <lcd.c>         // Librería para el manejo de la LCD
#include <MPU6050.c>     // Librería para el manejo del MPU6050
#include <servo_st.c>    // Librería para servos

// Parámetros PID y tiempo entre muestras
float Kp = 1.0;  // Ganancia proporcional
float Ki = 0.0;  // Ganancia integral
float Kd = 0.0;  // Ganancia derivativa
float setpoint = 0;  // Valor deseado para el ángulo
int sample_time = 500;  // Tiempo entre muestras (en milisegundos)

// Parámetros de ajuste fino
float fine_adjustment_threshold = 5.0;  // Umbral de error para entrar en el ajuste fino
float fine_adjustment_factor = 0.2;  // Factor de ajuste fino
int angle_x_previous = 90, angle_y_previous = 90; // Ángulos previos

float integral_x = 0, integral_y = 0;
float previous_error_x = 0, previous_error_y = 0;

float pid_control(float error, float* integral, float* previous_error, float Kp, float Ki, float Kd) {
    // Calcular la parte proporcional
    float P = Kp * error;

    // Calcular la parte integral
    *integral += error;
    float I = Ki * (*integral);

    // Calcular la parte derivativa
    float D = Kd * (error - *previous_error);

    // Actualizar el error previo para la próxima iteración
    *previous_error = error;

    // Salida del PID
    return P + I + D;
}

// Función para el ajuste fino
void fine_tune_adjustment(float* angle, float error, float fine_adjustment_factor) {
    if (fabs(error) < fine_adjustment_threshold) {
        // Si el error es pequeño, hacer ajustes finos sumando o restando 1 grado
        if (error > 0) {
            *angle += 1;  // Aumentar el ángulo
        } else {
            *angle -= 1;  // Disminuir el ángulo
        }
    }
}

void menu_configuracion() {
    // Menu interactivo para cambiar PID y setpoint
    int option = 0;  // 0 -> Kp, 1 -> Ki, 2 -> Kd, 3 -> Setpoint, 4 -> Sample Time
    while (true) {
        // Mostrar el menú y las opciones
        lcd_gotoxy(1, 1);
        delay_ms(200);
        if (option == 0) printf(lcd_putc, "\fKp: %.2f", Kp);
        if (option == 1) printf(lcd_putc, "\fKi: %.2f", Ki);
        if (option == 2) printf(lcd_putc, "\fKd: %.2f", Kd);
        if (option == 3) printf(lcd_putc, "\fSetpoint: %.2f", setpoint);
        if (option == 4) printf(lcd_putc, "\fTime: %d", sample_time);

        // Comprobamos si se presionaron los botones
        if (input(PIN_B0) == 0) {
            delay_ms(50);  // Retardo para evitar rebote
            if (input(PIN_B0) == 0) return;  // Salir del menú si se presiona RB0
        }

        if (input(PIN_B3) == 0) {
            delay_ms(50);  // Retardo para evitar rebote
            if (input(PIN_B3) == 0) {
                option = (option + 1) % 5;  // Cambiar opción (RB3)
                delay_ms(200);  // Para evitar rebotes
            }
        }

        if (input(PIN_B1) == 0) {
            delay_ms(50);  // Retardo para evitar rebote
            if (input(PIN_B1) == 0) {
                // Incrementar el valor
                if (option == 0) Kp += 0.1;
                if (option == 1) Ki += 0.1;
                if (option == 2) Kd += 0.1;
                if (option == 3) setpoint += 0.1;
                if (option == 4) sample_time += 10;
                delay_ms(200);  // Para evitar rebotes
            }
        }

        if (input(PIN_B2) == 0) {
            delay_ms(50);  // Retardo para evitar rebote
            if (input(PIN_B2) == 0) {
                // Disminuir el valor
                if (option == 0) Kp -= 0.1;
                if (option == 1) Ki -= 0.1;
                if (option == 2) Kd -= 0.1;
                if (option == 3) setpoint -= 0.1;
                if (option == 4) sample_time -= 10;
                delay_ms(200);  // Para evitar rebotes
            }
        }
    }
}

void main() {
    lcd_init();
    MPU6050_init();  // Inicializa el MPU6050
    servo_init();    // Inicializa los servos

    printf(lcd_putc, "BIENVENIDO");

    float Ax, Ay;
    int angle_x, angle_y;
    float error_x, error_y;
    float correction_x, correction_y;

    while (true) {
        // Si se presiona RB0, entra al menú de configuración
        if (input(PIN_B0) == 0) {
            menu_configuracion();
            delay_ms(200);  // Para evitar rebotes
        }

        // Obtener los valores del giroscopio
        Ax = MPU6050_get_Ax();
        Ay = MPU6050_get_Ay();

        // Convertir a valores enteros
        int x_angle = (int)(Ax * 100);
        int y_angle = (int)(Ay * 100);

        // Mostrar los valores en la pantalla LCD
        lcd_gotoxy(1, 1);
        printf(lcd_putc, "\fAx:%d Ay:%d", x_angle, y_angle);

        // Calcular el error para el control PID (el valor deseado es el setpoint)
        error_x = setpoint - x_angle;
        error_y = setpoint - y_angle;

        // Calcular las correcciones PID para ambos ejes
        correction_x = pid_control(error_x, &integral_x, &previous_error_x, Kp, Ki, Kd);
        correction_y = pid_control(error_y, &integral_y, &previous_error_y, Kp, Ki, Kd);

        // Calcular el ángulo de los servos basado en el punto neutro de 90 grados
        angle_x = 90 - (int)correction_x;
        angle_y = 90 - (int)correction_y;

        // Enviar los movimientos a los servos
        servo_1_write(angle_x);
        delay_ms(sample_time);
        servo_2_write(angle_y);
        delay_ms(sample_time);

        // Aplicar el ajuste fino
        while (fabs(error_x) > fine_adjustment_threshold || fabs(error_y) > fine_adjustment_threshold) {
            // Aplicar el ajuste fino
            fine_tune_adjustment(&angle_x, error_x, fine_adjustment_factor);
            fine_tune_adjustment(&angle_y, error_y, fine_adjustment_factor);

            // Enviar el ajuste a los servos
            servo_1_write(angle_x);
            delay_ms(sample_time);
            servo_2_write(angle_y);
            delay_ms(sample_time);

            // Recalcular errores
            error_x = setpoint - x_angle;
            error_y = setpoint - y_angle;
        }
    }
}

