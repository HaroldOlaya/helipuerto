#include <16f877a.h>
#include <math.h>  // Para usar atan
#include <stdbool.h>
#fuses HS, NOWDT, NOPROTECT, NOPUT, NOLVP, NOBROWNOUT
#use delay(clock=20000000)
#use I2C(MASTER, SDA=PIN_C4, SCL=PIN_C3, SLOW)

#use standard_io(D)
#use standard_io(A)
#define use_servo_1 
#define use_servo_2
// Definiciones de pines para los servos
#define servo_1 PIN_A0
#define servo_2 PIN_A1

#include <lcd.c>         // Librería para el manejo de la LCD
#include <MPU6050.c>     // Librería para el manejo del MPU6050
#include <servo_st.c>    // Librería para servos

// Parámetros PID y tiempo entre muestras
float Kp = 1.0;  // Ganancia proporcional
float Ki = 0.0;  // Ganancia integral
float Kd = 0.0;  // Ganancia derivativa
float setpoint = 0;  // Valor deseado para el ángulo
int sample_time = 500;  // Tiempo entre muestras (en milisegundos)

// Parámetros de ajuste fino
float fine_adjustment_threshold = 5.0;  // Umbral de error para entrar en el ajuste fino
float fine_adjustment_factor = 0.2;  // Factor de ajuste fino

float integral_x = 0, integral_y = 0;
float previous_error_x = 0, previous_error_y = 0;

bool ultimo_ajuste(int x_before, int y_before) {
    float Ax, Ay;
    int x_angle, y_angle;
    int new_angle =x_before;
    bool perfx=false;
    bool perfy=false;
    // Bucle que se repite hasta que ambos ángulos sean 0
    do {
        // Obtener los valores del giroscopio
        Ax = MPU6050_get_Ax();
        Ay = MPU6050_get_Ay();

        // Convertir los valores a ángulos (ajustar según sea necesario)
        x_angle = (int)(Ax * 100);  // Ajusta según sea necesario
        y_angle = (int)(Ay * 100);  // Ajusta según sea necesario
        while(!perfx){
           if(x_angle > (setpoint+2)){
            new_angle++;
            servo_1_write(new_angle);
            delay_ms(sample_time);
           }
           if(x_angle < (setpoint-2)){
            new_angle--;
            servo_1_write(new_angle);
            delay_ms(sample_time);
           }
           else{
            perfx=true;
           }
           lcd_gotoxy(1, 1);  // Mover el cursor a la segunda línea
           printf(lcd_putc, "\fAx: %d  Ay: %d", x_angle, y_angle);  // Mostrar los valores del giroscopio
           delay_ms(200);
        }
        while (!perfy) {
            if (y_angle > (setpoint + 2)) {
                new_angle++;  // Incrementar el ángulo
                servo_2_write(new_angle);  // Mueve el segundo servo
                delay_ms(sample_time);
            }
            else if (y_angle < (setpoint - 2)) {
                new_angle--;  // Decrementar el ángulo
                servo_2_write(new_angle);  // Mueve el segundo servo
                delay_ms(sample_time);
            }
            else {
                perfy = true;  // Si está dentro del rango de tolerancia, salir del bucle
            }
           lcd_gotoxy(1, 1);  // Mover el cursor a la segunda línea
           printf(lcd_putc, "\fAx: %d  Ay: %d", x_angle, y_angle);  // Mostrar los valores del giroscopio
           delay_ms(200);
        }
    } while (x_angle != 0 || y_angle != 0);

    // Si ambos son 0, retornar true
    return true;
}


float pid_control(float error, float* integral, float* previous_error, float Kp, float Ki, float Kd) {
    // Calcular la parte proporcional
    float P = Kp * error;

    // Calcular la parte integral
    *integral += error;
    float I = Ki * (*integral);

    // Calcular la parte derivativa
    float D = Kd * (error - *previous_error);

    // Actualizar el error previo para la próxima iteración
    *previous_error = error;

    // Salida del PID
    return P + I + D;
}

// Función para el ajuste fino
float fine_tune_adjustment(float error, float current_correction, float fine_adjustment_factor) {
    if (fabs(error) < fine_adjustment_threshold) {
        // Si el error es pequeño, aplicar un ajuste fino
        return current_correction * fine_adjustment_factor;
    }
    return current_correction;
}

void menu_configuracion() {
    // Menu interactivo para cambiar PID y setpoint
    int option = 0;  // 0 -> Kp, 1 -> Ki, 2 -> Kd, 3 -> Setpoint, 4 -> Sample Time
    while (true) {
        // Mostrar el menú y las opciones
        lcd_gotoxy(1, 1);
        delay_ms(200);
        if (option == 0) printf(lcd_putc, "\fKp: %.2f", Kp);
        if (option == 1) printf(lcd_putc, "\fKi: %.2f", Ki);
        if (option == 2) printf(lcd_putc, "\fKd: %.2f", Kd);
        if (option == 3) printf(lcd_putc, "\fSetpoint: %.2f", setpoint);
        if (option == 4) printf(lcd_putc, "\fTime: %d", sample_time);

        // Comprobamos si se presionaron los botones
        if (input(PIN_B0) == 0) {
            delay_ms(50);  // Retardo para evitar rebote
            if (input(PIN_B0) == 0) return;  // Salir del menú si se presiona RB0
        }

        if (input(PIN_B3) == 0) {
            delay_ms(50);  // Retardo para evitar rebote
            if (input(PIN_B3) == 0) {
                option = (option + 1) % 5;  // Cambiar opción (RB3)
                delay_ms(200);  // Para evitar rebotes
            }
        }

        if (input(PIN_B1) == 0) {
            delay_ms(50);  // Retardo para evitar rebote
            if (input(PIN_B1) == 0) {
                // Incrementar el valor
                if (option == 0) Kp += 0.1;
                if (option == 1) Ki += 0.1;
                if (option == 2) Kd += 0.1;
                if (option == 3) setpoint += 0.1;
                if (option == 4) sample_time += 10;
                delay_ms(200);  // Para evitar rebotes
            }
        }

        if (input(PIN_B2) == 0) {
            delay_ms(50);  // Retardo para evitar rebote
            if (input(PIN_B2) == 0) {
                // Disminuir el valor
                if (option == 0) Kp -= 0.1;
                if (option == 1) Ki -= 0.1;
                if (option == 2) Kd -= 0.1;
                if (option == 3) setpoint -= 0.1;
                if (option == 4) sample_time -= 10;
                delay_ms(200);  // Para evitar rebotes
            }
        }
    }
}

void main() {
    lcd_init();
    MPU6050_init();  // Inicializa el MPU6050
    servo_init();    // Inicializa los servos

    printf(lcd_putc, "BIENVENIDO");

    float Ax, Ay;
    int angle_x, angle_y;

    while (true) {
        // Si se presiona RB0, entra al menú de configuración
        if (input(PIN_B0) == 0) {
            menu_configuracion();
            delay_ms(200);  // Para evitar rebotes
        }

        // Obtener los valores del giroscopio
        Ax = MPU6050_get_Ax();
        Ay = MPU6050_get_Ay();

        // Convertir a valores enteros
        int x_angle = (int)(Ax * 100);
        int y_angle = (int)(Ay * 100);

        // Mostrar los valores en la pantalla LCD
        lcd_gotoxy(1, 1);
        printf(lcd_putc, "\fAx:%d Ay:%d", x_angle, y_angle);

        // Calcular el error para el control PID (el valor deseado es el setpoint)
        float error_x = setpoint - x_angle;
        float error_y = setpoint - y_angle;

        // Calcular las correcciones PID para ambos ejes
        float correction_x = pid_control(error_x, &integral_x, &previous_error_x, Kp, Ki, Kd);
        float correction_y = pid_control(error_y, &integral_y, &previous_error_y, Kp, Ki, Kd);

        // Calcular el ángulo de los servos basado en el punto neutro de 90 grados
        angle_x = 90 - (int)correction_x;
        angle_y = 90 - (int)correction_y;

        // Enviar los movimientos a los servos
        servo_1_write(angle_x);
        delay_ms(sample_time);
        servo_2_write(angle_y);
        delay_ms(sample_time);

        bool correccion = ultimo_ajuste(angle_x,angle_y)
        
    }
}

