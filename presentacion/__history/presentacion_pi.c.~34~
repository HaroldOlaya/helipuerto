#include <16f877a.h>
#include <math.h>  // Para usar atan

#fuses HS, NOWDT, NOPROTECT, NOPUT, NOLVP, NOBROWNOUT
#use delay(clock=20000000)
#use I2C(MASTER, SDA=PIN_C4, SCL=PIN_C3, SLOW)

#use standard_io(D)
#use standard_io(A)
#define use_servo_1 
#define use_servo_2
// Definiciones de pines para los servos
#define servo_1 PIN_A0
#define servo_2 PIN_A1

// Librería adicional para el manejo de servos
#define BUTTON_UP PIN_B1      // Botón para incrementar valor
#define BUTTON_DOWN PIN_B2    // Botón para decrementar valor
#define BUTTON_SELECT PIN_B3  // Botón para confirmar selección
#define BUTTON_MENU PIN_B0  

#include <lcd.c>         // Librería para el manejo de la LCD
#include <MPU6050.c>     // Librería para el manejo del MPU6050
#include <servo_st.c>    // Librería para servos


// Variables para PID y Setpoint para X y Y
float kp_x = 0.2, ki_x = 0.05, kd_x = 0.01;
float kp_y = 0.2, ki_y = 0.05, kd_y = 0.01;
float setpoint_x = 0.0, setpoint_y = 0.0;  // Setpoints en grados
float last_error_x = 0.0, integral_x = 0.0;
float last_error_y = 0.0, integral_y = 0.0;

// Rango permitido cercano al cero
float tolerance = 2.0;  // Rango de ±2 grados

// Variables para control de tiempo
unsigned long last_time = 0;  // Almacenará el último tiempo en milisegundos

// Función para obtener el valor absoluto de un número de punto flotante
float abs_float(float value) {
    return value < 0 ? -value : value;
}

// Función PID para controlar cada eje
float pid_control_x(float input) {
    float error = setpoint_x - input;

    if (abs_float(error) < tolerance) {
        error = 0;  // Si el error es menor que el rango, no ajustar más
    }

    integral_x += error;
    float derivative = error - last_error_x;
    float output = kp_x * error + ki_x * integral_x + kd_x * derivative;
    last_error_x = error;

    // Limitar la salida PID entre 0 y 180 grados
    if (output < 0.0) output = 0.0;
    if (output > 180.0) output = 180.0;
    return output;
}

float pid_control_y(float input) {
    float error = setpoint_y - input;

    if (abs_float(error) < tolerance) {
        error = 0;
    }

    integral_y += error;
    float derivative = error - last_error_y;
    float output = kp_y * error + ki_y * integral_y + kd_y * derivative;
    last_error_y = error;

    if (output < 0.0) output = 0.0;
    if (output > 180.0) output = 180.0;
    return output;
}

// Función para mostrar el menú de configuración PID
void pid_menu() {
    int option = 0;
    int done = 0;

    while (!done) {
        lcd_putc("\f");  // Limpiar pantalla
        lcd_gotoxy(1, 1);

        switch (option) {
            case 0:
                printf(lcd_putc, "Kp X: %.2f", kp_x);
                break;
            case 1:
                printf(lcd_putc, "Ki X: %.2f", ki_x);
                break;
            case 2:
                printf(lcd_putc, "Kd X: %.2f", kd_x);
                break;
            case 3:
                printf(lcd_putc, "Kp Y: %.2f", kp_y);
                break;
            case 4:
                printf(lcd_putc, "Ki Y: %.2f", ki_y);
                break;
            case 5:
                printf(lcd_putc, "Kd Y: %.2f", kd_y);
                break;
            case 6:
                printf(lcd_putc, "Setpoint X: %.2f", setpoint_x);
                break;
            case 7:
                printf(lcd_putc, "Setpoint Y: %.2f", setpoint_y);
                break;
        }

        if (input(BUTTON_UP) == 0) {
            while (input(BUTTON_UP) == 0);
            switch (option) {
                case 0: kp_x += 0.05; break;
                case 1: ki_x += 0.1; break;
                case 2: kd_x += 0.01; break;
                case 3: kp_y += 0.05; break;
                case 4: ki_y += 0.1; break;
                case 5: kd_y += 0.01; break;
                case 6: setpoint_x += 0.1; break;
                case 7: setpoint_y += 0.1; break;
            }
        }

        if (input(BUTTON_DOWN) == 0) {
            while (input(BUTTON_DOWN) == 0);
            switch (option) {
                case 0: kp_x -= 0.05; break;
                case 1: ki_x -= 0.1; break;
                case 2: kd_x -= 0.01; break;
                case 3: kp_y -= 0.05; break;
                case 4: ki_y -= 0.1; break;
                case 5: kd_y -= 0.01; break;
                case 6: setpoint_x -= 0.1; break;
                case 7: setpoint_y -= 0.1; break;
            }
        }

        if (input(BUTTON_SELECT) == 0) {
            while (input(BUTTON_SELECT) == 0);
            option++;
            if (option > 7) {
                done = 1;
            }
        }
        delay_ms(200);
    }
}

// Rutina de interrupción para el menú PID
#INT_EXT
void interrupt_rb0() {
    pid_menu();
}

void main() {
    lcd_init();
    MPU6050_init();  // Inicializa el MPU6050
    servo_init();    // Inicializa los servos
    enable_interrupts(INT_EXT);
    enable_interrupts(GLOBAL);
    ext_int_edge(H_TO_L);

    printf(lcd_putc, "BIENVENIDO");

    float Ax, Ay, servo_x_output, servo_y_output;

    while (true) {
        // Obtener los valores de los ángulos
        Ax = MPU6050_get_Ax();  // Obtener valor en el eje X
        Ay = MPU6050_get_Ay();  // Obtener valor en el eje Y

        // Mostrar los valores de los ángulos en la pantalla LCD
        lcd_gotoxy(1, 1);
        printf(lcd_putc, "\fAx:%d Ay:%d", (int)(Ax * 100), (int)(Ay * 100));// Mostrar como valores flotantes para precisión

        // Movimiento del servo 1 (X)
        servo_x_output = pid_control_x(Ax);
        // Ajuste del servo X: si Ax es positivo, sumamos a 90; si es negativo, restamos
        if (Ax > 0) {
            servo_x_output = 90 - servo_x_output;  // Mueve el servo en el eje X hacia la derecha
        } else {
            servo_x_output = 90 + servo_x_output;  // Mueve el servo en el eje X hacia la izquierda
        }
        servo_1_write(servo_x_output);  // Mueve el servo en el eje X
        delay_ms(1000);  // Espera 1 segundo entre movimientos

        // Movimiento del servo 2 (Y)
        servo_y_output = pid_control_y(Ay);
        // Ajuste del servo Y: si Ay es positivo, sumamos a 90; si es negativo, restamos
        if (Ay > 0) {
            servo_y_output = 90 + servo_y_output;  // Mueve el servo en el eje Y hacia arriba
        } else {
            servo_y_output = 90 - servo_y_output;  // Mueve el servo en el eje Y hacia abajo
        }
        servo_2_write(servo_y_output);  // Mueve el servo en el eje Y
        delay_ms(1000);
        lcd_gotoxy(1, 2);
        printf(lcd_putc, "\fCx:%f Cy:%f", servo_y_output, servo_x_output);// Espera 1 segundo entre movimientos
         delay_ms(500);
        // Ya casi
    }
}

