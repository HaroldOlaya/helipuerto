#include <16f877a.h>
#include <math.h>  // Para usar atan

#fuses HS, NOWDT, NOPROTECT, NOPUT, NOLVP, NOBROWNOUT
#use delay(clock=20000000)
#use I2C(MASTER, SDA=PIN_C4, SCL=PIN_C3, SLOW)

#use standard_io(D)
#use standard_io(A)

#define BUTTON_UP PIN_B1      // Botón para incrementar valor
#define BUTTON_DOWN PIN_B2    // Botón para decrementar valor
#define BUTTON_SELECT PIN_B3  // Botón para confirmar selección
#define BUTTON_MENU PIN_B0  

#include <lcd.c>         // Librería para el manejo de la LCD
#include <MPU6050.c>     // Librería para el manejo del MPU6050
#include <servo_st.c>    // Librería para servos

// Variables para PID y Setpoint para X y Y
float kp_x = 0.2, ki_x = 0.05, kd_x = 0.01;
float kp_y = 0.2, ki_y = 0.05, kd_y = 0.01;
float setpoint_x = 0.0, setpoint_y = 0.0;  // Setpoints en grados
float last_error_x = 0.0, integral_x = 0.0;
float last_error_y = 0.0, integral_y = 0.0;

// Rango permitido cercano al cero
float tolerance = 2.0;  // Rango de ±2 grados

// Variables para control de tiempo
unsigned long last_time = 0;  // Almacenará el último tiempo en milisegundos

// Función para obtener el valor absoluto de un número de punto flotante
float abs_float(float value) {
    return value < 0 ? -value : value;
}

// Función PID para controlar cada eje
float pid_control_x(float input) {
    float error = setpoint_x - input;

    if (abs_float(error) < tolerance) {
        error = 0;  // Si el error es menor que el rango, no ajustar más
    }

    integral_x += error;
    float derivative = error - last_error_x;
    float output = kp_x * error + ki_x * integral_x + kd_x * derivative;
    last_error_x = error;

    // Limitar la salida PID entre 0 y 180 grados
    if (output < 0.0) output = 0.0;
    if (output > 180.0) output = 180.0;
    return output;
}

float pid_control_y(float input) {
    float error = setpoint_y - input;

    if (abs_float(error) < tolerance) {
        error = 0;
    }

    integral_y += error;
    float derivative = error - last_error_y;
    float output = kp_y * error + ki_y * integral_y + kd_y * derivative;
    last_error_y = error;

    if (output < 0.0) output = 0.0;
    if (output > 180.0) output = 180.0;
    return output;
}

// Rutina de interrupción para el menú PID
#INT_EXT
void interrupt_rb0() {
    // Llamar al menú PID si se presiona un botón (puedes implementar aquí la lógica de tu menú)
}

// Función para aplicar corrección gradual en el eje X
void aplicar_correccion_x(float Ax) {
    float servo_x_output = pid_control_x(Ax);

    // Aplicar corrección gradual hacia el setpoint
    if (Ax > setpoint_x) {
        servo_x_output = 90 - (servo_x_output / 10.0);  // Ajuste gradual hacia la derecha
    } else if (Ax < setpoint_x) {
        servo_x_output = 90 + (servo_x_output / 10.0);  // Ajuste gradual hacia la izquierda
    }
    servo_1_write(servo_x_output);  // Enviar posición al servo
}

// Función para aplicar corrección gradual en el eje Y
void aplicar_correccion_y(float Ay) {
    float servo_y_output = pid_control_y(Ay);

    // Aplicar corrección gradual hacia el setpoint
    if (Ay > setpoint_y) {
        servo_y_output = 90 + (servo_y_output / 10.0);  // Ajuste gradual hacia arriba
    } else if (Ay < setpoint_y) {
        servo_y_output = 90 - (servo_y_output / 10.0);  // Ajuste gradual hacia abajo
    }
    servo_2_write(servo_y_output);  // Enviar posición al servo
}

void main() {
    lcd_init();
    MPU6050_init();  // Inicializa el MPU6050
    servo_init();    // Inicializa los servos
    enable_interrupts(INT_EXT);
    enable_interrupts(GLOBAL);
    ext_int_edge(H_TO_L);

    printf(lcd_putc, "BIENVENIDO");

    float Ax, Ay;

    while (true) {
        // Obtener los valores de los ángulos
        Ax = MPU6050_get_Ax();  // Obtener valor en el eje X
        Ay = MPU6050_get_Ay();  // Obtener valor en el eje Y

        // Mostrar los valores de los ángulos en la pantalla LCD
        lcd_gotoxy(1, 1);
        printf(lcd_putc, "\fAx:%d Ay:%d", (int)(Ax * 100), (int)(Ay * 100)); // Mostrar como valores flotantes para precisión

        // Aplicar corrección gradual para los ejes X e Y
        aplicar_correccion_x(Ax);
        aplicar_correccion_y(Ay);

        delay_ms(200);  // Espera breve entre correcciones
    }
}

