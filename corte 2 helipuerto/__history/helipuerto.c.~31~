#include <16f877a.h>
#include <math.h>  // Incluir la librería math.h para usar atan

// Configuración de fusibles
#fuses HS, NOWDT, NOPROTECT, NOPUT, NOLVP, NOBROWNOUT

// Configuración de velocidad del reloj
#use delay(clock=20000000)

// Configuración del bus I2C
#use I2C(MASTER, SDA=PIN_C4, SCL=PIN_C3, SLOW)

// Configuración de entrada/salida estándar para los puertos
#use standard_io(D)
#use standard_io(A)
#define use_servo_1 
#define use_servo_2 

// Definiciones para el uso de los servos
#define servo_1 PIN_A0   // Pin del servo 1
#define servo_2 PIN_A1   // Pin del servo 2

// Inclusión de librerías necesarias
#include <lcd.c>         // Librería para el manejo de la LCD
#include <MPU6050.c>     // Librería para el manejo del MPU6050
#include <servo_st.c>    // Librería adicional para el manejo de servos

// Declaración de variables para almacenar los datos del acelerómetro y giroscopio
float Ax, Ay, Az, Gx, Gy, Gz, t;
int angle_x, angle_y;

// Variables PID
float Kp_x = 1.0, Ki_x = 0.1, Kd_x = 0.05;  // Coeficientes PID para el eje X
float Kp_y = 1.0, Ki_y = 0.1, Kd_y = 0.05;  // Coeficientes PID para el eje Y
float error_x, error_y;                     // Errores
float prev_error_x = 0, prev_error_y = 0;  // Errores previos
float integral_x = 0, integral_y = 0;       // Integrales del error
float output_x, output_y;                    // Salidas del PID

void main() {
    // Configuración de los puertos
    set_tris_d(0x00);  // Configura el puerto D completo como salida para la LCD
    set_tris_a(0xFC);  // Configura A0 y A1 como salidas para los servos (los demás como entradas)
    
    // Inicialización de los módulos
    lcd_init();         // Inicializa la pantalla LCD
    servo_init();       // Inicializa el control de los servos
    MPU6050_init();
    printf(lcd_putc, " BIENVENIDO");
    delay_ms(1000);    // Espera inicial

    // Bucle principal
    while (true) {
        // Obtener datos del MPU6050
        Ax = MPU6050_get_Ax();  // Acelerómetro eje X
        Ay = MPU6050_get_Ay();  // Acelerómetro eje Y
        Az = MPU6050_get_Az();  // Acelerómetro eje Z
        
        Gx = MPU6050_get_Gx();  // Giroscopio eje X
        Gy = MPU6050_get_Gy();  // Giroscopio eje Y
        Gz = MPU6050_get_Gz();  // Giroscopio eje Z
        
        t = MPU6050_get_Temp(); // Temperatura

        // Mostrar datos en la pantalla LCD
        lcd_gotoxy(1, 1);  // Posición (1,1) en la LCD
        printf(lcd_putc, "Ax:%0.2f Ay:%0.2f", Ax, Ay);  // Imprime Ax y Ay en la primera línea
        
        lcd_gotoxy(1, 2);  // Posición (1,2) en la LCD
        printf(lcd_putc, "Gx:%0.2f Gy:%0.2f", Gx, Gy);  // Imprime Gx y Gy en la segunda línea
        
        delay_ms(200);  // Pequeño retraso para la actualización

        // Calcular el error para los servos
        error_x = 0 - Gx;  // Error para el servo 1 (deseado es 0)
        error_y = 0 - Gy;  // Error para el servo 2 (deseado es 0)

        // Calcular la integral del error
        integral_x += error_x;
        integral_y += error_y;

        // Calcular la derivada del error
        float derivative_x = error_x - prev_error_x;
        float derivative_y = error_y - prev_error_y;

        // Salida del PID
        output_x = Kp_x * error_x + Ki_x * integral_x + Kd_x * derivative_x;
        output_y = Kp_y * error_y + Ki_y * integral_y + Kd_y * derivative_y;

        // Actualizar el error previo
        prev_error_x = error_x;
        prev_error_y = error_y;

        // Calcular ángulos para los servos basados en la salida del PID
        angle_x = 90 + (int)output_x;  // Calcular ángulo del servo 1
        angle_y = 90 - (int)output_y;  // Calcular ángulo del servo 2
        
        // Limitar ángulos entre 0 y 180
        if (angle_x < 0) angle_x = 0;
        if (angle_x > 180) angle_x = 180;
        if (angle_y < 0) angle_y = 0;
        if (angle_y > 180) angle_y = 180;

        // Enviar los ángulos a los servos
        servo_1_write(angle_x);   // Mueve el servo 1 a angle_x
        delay_ms(200);           // Espera para que el servo complete el movimiento
        servo_2_write(angle_y);   // Mueve el servo 2 a angle_y
        delay_ms(200);           // Espera para que el servo complete el movimiento
    }
}

