#include <16f877a.h>

// Configuración de fusibles
#fuses HS, NOWDT, NOPROTECT, NOPUT, NOLVP, NOBROWNOUT

// Configuración de velocidad del reloj
#use delay(clock=20000000)

// Configuración del bus I2C
#use I2C(MASTER, SDA=PIN_C4, SCL=PIN_C3, SLOW)

// Configuración de entrada/salida estándar para los puertos
#use standard_io(D)
#use standard_io(A)

// Definiciones para el uso de los servos
#define servo_1 PIN_A0   // Pin del servo 1
#define servo_2 PIN_A1   // Pin del servo 2

// Inclusión de librerías necesarias
#include <lcd.c>         // Librería para el manejo de la LCD
#include <MPU6050.c>     // Librería para el manejo del MPU6050
#include <servo_st.c>    // Librería adicional para el manejo de servos

// Declaración de variables para almacenar los datos del acelerómetro y giroscopio
float Ax, Ay, Az;
float setpoint_x = 0.0, setpoint_y = 0.0;  // Valores deseados para los ángulos (nivelado)
float prev_error_x = 0, prev_error_y = 0;
float integral_x = 0, integral_y = 0;
float kp = 1.0, ki = 0.0, kd = 0.0;  // Parámetros PID iniciales

// Definición de atan2 para evitar dependencias externas
float atan2_approx(float y, float x) {
    if (x > 0) {
        return atan(y / x);
    } else if (x < 0 && y >= 0) {
        return atan(y / x) + 3.14159;
    } else if (x < 0 && y < 0) {
        return atan(y / x) - 3.14159;
    } else if (x == 0 && y > 0) {
        return 3.14159 / 2;
    } else if (x == 0 && y < 0) {
        return -3.14159 / 2;
    }
    return 0;
}

void main() {
    // Configuración de los puertos
    set_tris_d(0x00);  // Configura el puerto D completo como salida para la LCD
    set_tris_a(0xFC);  // Configura A0 y A1 como salidas para los servos (los demás como entradas)
    
    // Inicialización de los módulos
    lcd_init();         // Inicializa la pantalla LCD
    servo_init();       // Inicializa el control de los servos
    MPU6050_init();     // Inicializa el MPU6050

    // Mensaje de bienvenida en la LCD
    printf(lcd_putc, " BIENVENIDO");
    delay_ms(1000);

    // Bucle principal
    while (true) {
        // Obtener datos del MPU6050
        Ax = MPU6050_get_Ax();
        Ay = MPU6050_get_Ay();
        Az = MPU6050_get_Az();

        // Cálculo de los ángulos de inclinación utilizando los datos del acelerómetro
        float angle_x = atan2_approx(Ax, Az) * (180.0 / 3.14159);  // Convierte radianes a grados
        float angle_y = atan2_approx(Ay, Az) * (180.0 / 3.14159);  // Convierte radianes a grados

        // Mostrar ángulos en la pantalla LCD
        lcd_gotoxy(1, 1);
        printf(lcd_putc, "AngX:%0.2f", angle_x);
        lcd_gotoxy(1, 2);
        printf(lcd_putc, "AngY:%0.2f", angle_y);
        
        // Control PID para el eje X
        float error_x = setpoint_x - angle_x;
        integral_x += error_x;  // Componente integral
        float derivative_x = error_x - prev_error_x;  // Componente derivada
        prev_error_x = error_x;
        float correction_x = (kp * error_x) + (ki * integral_x) + (kd * derivative_x);
        
        // Control PID para el eje Y
        float error_y = setpoint_y - angle_y;
        integral_y += error_y;  // Componente integral
        float derivative_y = error_y - prev_error_y;  // Componente derivada
        prev_error_y = error_y;
        float correction_y = (kp * error_y) + (ki * integral_y) + (kd * derivative_y);

        // Limitar las correcciones a un rango de 0 a 180 grados
        if (correction_x > 180.0) correction_x = 180.0;
        if (correction_x < 0.0) correction_x = 0.0;
        if (correction_y > 180.0) correction_y = 180.0;
        if (correction_y < 0.0) correction_y = 0.0;

        // Controlar los servos con los valores calculados por el PID
        servo_1_write((int)correction_x);
        servo_2_write((int)correction_y);

        // Pequeño retraso para la actualización
        delay_ms(200);  
    }
}

